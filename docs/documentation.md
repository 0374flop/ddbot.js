# bot/BotManager
Окей...
Сейчас я вам разкажу как работает bot/BotManager.

neiky-ddracebot.js
## Базовые методы
У нас есть :
1. bot.createBot()
	1. fulladdress - Полный адрес сервера (IP:порт)
	2. botName - Имя бота
	3. parameter - Параметры бота
	    1. identity со скином и другими косметическими деталями.
	    2. reconnect переподключаеться бот или нет
	    3. reconnectAttempts количество возможных реконектов (-1 для безконечного)
	    4. randreconnect будет ли бот переключаться с чуть разной задержкой или нет (в районе 0 - 1 сек)
	- На выходе у нас имя бота по которому можно обращаться. (Уникальное имя бота или null в случае ошибки)
2. bot.connectBot()
    1. Принимает уникальное имя бота и подключает нужного.
    - На выхоте булевое значение (нет точных данных подключился ли бот или нет)
3. bot.disconnectBot()
    1. Принимает уникальное имя бота и отключает нужного.
    - Работает также как и connectBot().
4. bot.disconnectAllBots()
    Отключает всех ботов, не принимает аргументов.
    Под капотом disconnectBot().
5. bot.getBotInfo()
    1. Принимает уникальное имя бота и возвращает информацию про него.
    - Информация о боте или null, если бот не найден
6. bot.isBotConnected()
    1. Принимает уникальное имя бота.
    - Возвращает булевое значение.
7. bot.isFreezeBot()
    1. Принимает уникальное имя бота.
    - Возвращает булевое значение.
8. bot.setFreezeBot()
    Просто меняет значение того заморожен ли бот.
9. bot.getAllActiveBots()
	Получение всех активных ботов
	- Массив имен всех активных ботов
10. bot.getBotClient()
    1. Принимает уникальное имя бота.
    - Возвращает клиент neiky-ddracebot.js
11. bot.removeBot()
	Удаляет бота полностью.
    1. Принимает уникальное имя бота.
    - Возвращает булевое значение.
12. bot.getBot()
    1. Принимает уникальное имя бота.
    - Возвращает прокси-объект бота.
13. bot.(Тут нижнее подчеркивание, я не могу поставить из-за обсидиана, он ломается)setupBotEvents()
    Заставляет ивенты работать. Изпользуеться в bot.createBot() чтобы вы могли делать все проще и вам не нужно было получать оригинальный клиент neiky-ddracebot.js
    1. Принимает уникальное имя бота.
    2. Принимает клиент neiky-ddracebot.js
    Ничего не возвращает.
14. bot.getPlayerList()
    1. Принимает уникальное имя бота.
    - Array список игроков.
15. bot.getPlayerName()
    1. Принимает уникальное имя бота/Array список игроков.
    2. clientid нужного игрока.
    - Имя нужного игрока.


# maploader
Возможно первая вещь которая может загружать карты по официальным названиям ДДНета.

## Самые нужные
fetchMapType и loadMap.

1. fetchMapType
    Получает тип карты с ddnet.org
    1. mapName - Имя карты.
    - Тип карты (novice тд.).
2. loadMap
	Загружает карту по нужному имени в нужную директорию.
	1. mapName - Имя карты.
	2. MAP_DIR - Директория куда будет загружена карта.
	- Возвращает булевое значение.

## Дополнитильные или сырые функции
Находиться в advanced
Тут есть сырой downloadMap, tryDownloadMap, logDebuger.

1. downloadMap
    Загрузка карты по имени и типу.
    Нет никакого протекшена почти.
    1. mapName - Имя карты
    2. type - Тип карты
    3. MAP_DIR_DM - Папка для загрузки карты
    - Путь к загруженной карте
2. tryDownloadMap
	Принимает все тоже что и downloadMap, только оборачивает его в try.
	- Возвращает болевое значение.

logDebuger из debug.js


# automaploader.js
Хуйня.
Не работает не с официальными ДДНет серверами, потому что они уже дают нам mapDetails.map_url а automaploader загружает по имени.
Мне лень переделывать его. пусть будет.

Если хотите понять как им пользоваться, лутше сами посмотрите его. он очень простой и маленький.

# debug.js / DebugLogger
Главный логер для отладки. Позволяет гибко настраивать вывод отладочной информации с поддержкой цветного текста через chalk.

## Конструктор
```javascript
new DebugLogger(prefix, isDebug, islog, prefixforprefix, chalk)
```

### Параметры конструктора:
1. **prefix** (string) - Префикс для всех отладочных сообщений. По умолчанию "null".
2. **isDebug** (boolean) - Включен ли режим отладки. По умолчанию false.
3. **islog** (boolean) - Использовать console.log вместо console.debug. По умолчанию true.
4. **prefixforprefix** (Array) - Массив из двух элементов [начало, конец] для оформления префикса. По умолчанию ['[', ']'].
5. **chalk** (boolean) - Использовать ли цветной текст. По умолчанию true (если chalk установлен).

## Свойства класса
1. **isDebug** (boolean) - Флаг включения/выключения режима отладки
2. **islog** (boolean) - Флаг использования console.log вместо console.debug
3. **prefix** (string) - Текущий префикс для сообщений
4. **prefixforprefix** (Array) - Символы для оформления префикса [начало, конец]
5. **chalk** (boolean) - Флаг использования цветного текста

## Методы класса

### logDebug(...args)
Выводит отладочное сообщение с префиксом, если режим отладки включен.

**Параметры:**
- ...args - Любые данные для логирования (можно передать несколько аргументов)

**Возвращаемое значение:** ничего (void)

**Описание:**
Метод проверяет, включен ли режим отладки (this.isDebug). Если да, то форматирует сообщение с префиксом и выводит его в консоль. Если islog = true, используется console.log, иначе console.debug.

**Формат вывода:**
- С цветом: `[серый]зелёный_префикс[серый] синее_сообщение`
- Без цвета: `[префикс] сообщение`

### setDebugMode(debugMode, useLog, chalk)
Изменяет режим отладки и способ вывода логов.

**Параметры:**
1. debugMode (boolean) - Включить (true) или выключить (false) режим отладки
2. useLog (boolean) - Использовать console.log (true) или console.debug (false). По умолчанию true.
3. chalk (boolean) - Использовать цветной текст. По умолчанию текущее значение this.chalk

**Возвращаемое значение:** ничего (void)

**Описание:**
Позволяет динамически менять режим отладки без пересоздания объекта. Полезно для переключения между режимами во время выполнения программы.

## Примеры использования

### Базовый пример
```javascript
const DebugLogger = require('ddbot.js-0374').DebugLogger;

// Создаем логер с префиксом 'MyBot'
const logger = new DebugLogger('MyBot', true, true, ['[', ']'], true);

// Выводим сообщение в console.log с цветом
logger.logDebug('Бот успешно запущен');
```

### Пример с переключением режимов
```javascript
const logger = new DebugLogger('Server', true, true);

// Выводит в console.log
logger.logDebug('Сервер запустился');

// Выключаем отладку
logger.setDebugMode(false);

// Это сообщение не будет выведено
logger.logDebug('Это не видно');

// Включаем отладку с console.debug вместо console.log
logger.setDebugMode(true, false);

// Выводит в console.debug
logger.logDebug('Переключились на console.debug');
```

### Пример с пользовательским оформлением
```javascript
const logger = new DebugLogger(
    'ERROR',
    true,
    true,
    ['<<< ', ' >>>'],  // Кастомное оформление
    true
);

// Выведет: <<< ERROR >>> ошибка произошла
logger.logDebug('ошибка произошла');
```

### Пример без цветного текста
```javascript
const logger = new DebugLogger('Bot', true, true, ['[', ']'], false);

// Выведет обычный текст без цветов
logger.logDebug('Обычный лог без цветов');
```

## Цветовая схема
Если chalk включен и найден в зависимостях, применяется следующая схема окраски:
- **Скобки-префиксы** [начало и конец] - серый цвет (grey)
- **Сам префикс** - зелёный цвет (green)
- **Сообщение** - синий цвет (blue)

Если chalk отключен или не установлен - все выводится обычным текстом без стилизации.

## Внутренние методы

### _format(prefix, prefixforprefix, ...args)
(Для внутреннего использования)

Форматирует сообщение с цветовыми кодами (если включен chalk).

**Параметры:**
- prefix (string) - Префикс сообщения
- prefixforprefix (Array) - Символы для оформления
- ...args - Аргументы для логирования

**Возвращаемое значение:** Array - Отформатированное сообщение (массив цветных строк или обычный массив)

**Описание:**
Метод используется внутри logDebug для форматирования вывода. Если chalk доступен, возвращает массив с цветными строками для console.log/debug. Иначе возвращает обычный массив.

## Тестирование
Для тестирования класса используйте:
```bash
node debug.js
```

При прямом запуске файла как скрипта DebugLogger автоматически создает несколько экземпляров и демонстрирует различные режимы работы.